Consider the state machine defined in the following transition table:

{
    'transitions': [
        {'current_state': 'A', 'output': '0', 'input': '0', 'next_state': 'B'},
        {'current_state': 'A', 'output': '0', 'input': '1', 'next_state': 'A'},
        {'current_state': 'B', 'output': '0', 'input': '0', 'next_state': 'C'},
        {'current_state': 'B', 'output': '0', 'input': '1', 'next_state': 'D'},
        {'current_state': 'C', 'output': '0', 'input': '0', 'next_state': 'E'},
        {'current_state': 'C', 'output': '0', 'input': '1', 'next_state': 'D'},
        {'current_state': 'D', 'output': '0', 'input': '0', 'next_state': 'F'},
        {'current_state': 'D', 'output': '0', 'input': '1', 'next_state': 'A'},
        {'current_state': 'E', 'output': '1', 'input': '0', 'next_state': 'E'},
        {'current_state': 'E', 'output': '1', 'input': '1', 'next_state': 'D'},
        {'current_state': 'F', 'output': '1', 'input': '0', 'next_state': 'C'},
        {'current_state': 'F', 'output': '1', 'input': '1', 'next_state': 'D'}
    ]
}

Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].

module TopModule (
  input [3:1] y,
  input w,
  output reg Y2
);