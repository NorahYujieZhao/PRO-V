Consider the state machine shown below:

[{
    "transitions": [
        {"current_state": "A", "output": 0, "input": 0, "next_state": "B"},
        {"current_state": "A", "output": 0, "input": 1, "next_state": "A"},
        {"current_state": "B", "output": 0, "input": 0, "next_state": "C"},
        {"current_state": "B", "output": 0, "input": 1, "next_state": "D"},
        {"current_state": "C", "output": 0, "input": 0, "next_state": "E"},
        {"current_state": "C", "output": 0, "input": 1, "next_state": "D"},
        {"current_state": "D", "output": 0, "input": 0, "next_state": "F"},
        {"current_state": "D", "output": 0, "input": 1, "next_state": "A"},
        {"current_state": "E", "output": 1, "input": 0, "next_state": "E"},
        {"current_state": "E", "output": 1, "input": 1, "next_state": "D"},
        {"current_state": "F", "output": 1, "input": 0, "next_state": "C"},
        {"current_state": "F", "output": 1, "input": 1, "next_state": "D"}
    ]
}]

Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.

Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding.

module TopModule (
  input [6:1] y,
  input w,
  output Y2,
  output Y4
);